# -*- coding: utf-8 -*-
"""FinalLungCancer.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/107J8ZgcvqxFkcb1DgTUCCg2oKkvdAj_7
"""

import torch
from PIL import Image
import torchvision.transforms as transforms
from cv2 import (VideoCapture, namedWindow, imshow, waitKey, destroyWindow, imwrite)
import cv2 as cv
import numpy as np
import cv2
import pandas as pd
import time
import imageio
from matplotlib import cm
import math
import tkinter
from tkinter import Frame
from matplotlib.font_manager import FontProperties
from PIL import Image
import cv2
from PIL import Image, ImageTk
import tkinter as tk
from datetime import datetime
import matplotlib.pyplot as plt
from detect import run as yolorun
import threading


class YoloFrame:
    def __init__(self):
        self.image = None

    def set_frame(self, image):
        self.image = image

class GraphGyro:
    def __init__(self, x,y,z):
        self.fig, self.ax = plt.subplots(figsize=(8, 5))
        self.fig.patch.set_facecolor('#121212')
        self.ax.set_facecolor('#121212')
        self.ax.spines['bottom'].set_color('#fff')
        self.ax.spines['left'].set_color('#fff')
        self.ax.spines['top'].set_visible(False)
        self.ax.spines['right'].set_visible(False)
        self.ax.tick_params(axis='x', colors='#fff')
        self.ax.tick_params(axis='y', colors='#fff')
        self.ax.set_title("X,Y,Z Coordinates", color='#fff')
        self.ax.set_xlabel("Time(s)", color='#fff')
        self.ax.set_ylabel("Relative Distance", color='#fff')
        self.x = x
        self.y = y
        self.z = z
        self.draw()
        self.fig.savefig('gyro_data.png')

    def draw(self):
        length = np.arange(len(self.x))
        x = self.x
        y = self.y
        z = self.z
        self.ax.plot(length, x, color='#ff0066', linewidth=2)
        self.ax.plot(length, y, color='#5d00ff',linewidth=2)
        self.ax.plot(length, z, color='#07a822',linewidth=2)
        self.ax.set_ylim(0, 1)
        self.fig.canvas.draw()
class Graph:
    def __init__(self, data,dv):
        self.fig, self.ax = plt.subplots(figsize=(8, 5))
        self.fig.patch.set_facecolor('#121212')
        self.ax.set_facecolor('#121212')
        self.ax.spines['bottom'].set_color('#fff')
        self.ax.spines['left'].set_color('#fff')
        self.ax.spines['top'].set_visible(False)
        self.ax.spines['right'].set_visible(False)
        self.ax.tick_params(axis='x', colors='#fff')
        self.ax.tick_params(axis='y', colors='#fff')
        self.ax.set_title("Depth Over Time", color='#fff')
        self.ax.set_xlabel("Time(s)", color='#fff')
        self.ax.set_ylabel("Relative Depth", color='#fff')
        self.data = data
        self.dv = dv
        self.draw()
        self.fig.savefig('my_plot.png')

    def draw(self):
        x = np.arange(len(self.data))
        y = self.data
        y2 = self.dv
        self.ax.plot(x, y, color='#ff0066', linewidth=2)
        self.ax.plot(x, y2, color='#5d00ff',linewidth=2)
        max_val = np.max(y)
        min_val = np.min(y)
        self.ax.set_ylim(0, 1)
        self.fig.canvas.draw()
def mid_test(img):
    #     model_type = "DPT_Large"
    model_type = "MiDaS_small"

    midas = torch.hub.load("intel-isl/MiDaS", model_type)

    device = torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu")
    midas.to(device)

    midas.eval()

    midas_transforms = torch.hub.load("intel-isl/MiDaS", "transforms")

    if model_type == "DPT_Large" or model_type == "DPT_Hybrid":
        transform = midas_transforms.dpt_transform
    else:
        transform = midas_transforms.small_transform

    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

    input_batch = transform(img).to(device)

    with torch.no_grad():
        prediction = midas(input_batch)

        prediction = torch.nn.functional.interpolate(
            prediction.unsqueeze(1),
            size=img.shape[:2],
            mode="bicubic",
            align_corners=False,
        ).squeeze()

    output = prediction.cpu().numpy()

    return output
def sigmoid(x):
    if (x < 0.1):
        x = 1 - x
        return 1/(1 + math.e ** (-30 * (x-1))) + sigmoid(0.1)
    elif (x < 0.3):
        x = 1-x
        return 1/(1 + math.e ** (-15 * (x-1))) + sigmoid(0.3)
    else:
        x = 1-x
        return 1/(1 + math.e ** (-10 * (x-1)))
def run(frame):

    curr_res = None

    results_new = model(frame)

    plt.imsave("Curr_Tumor.png", frame)

    print("RES:", results_new.pandas().xyxy[0])

    x1, y1, x2, y2 = None, None, None, None
    img_new = None
    conf_val_new = None

    if len(results_new.pandas().xyxy[0]) > 0:

        n_output = mid_test(frame)

        results_new = results_new.xyxy[0].cpu().numpy()

        high_depth = -1
        curr_res = None

        plt.imsave("Test.png", n_output, cmap=cm.gray)
        new_im = imageio.imread("Test.png")
        img_updated = cv2.cvtColor(new_im, cv2.COLOR_BGR2GRAY)
        img_reverted = cv2.bitwise_not(img_updated)
        img_new = img_reverted / 255.0

        for result_new in results_new:

            x1_t, y1_t, x2_t, y2_t, conf_val_new, class_id_new = result_new

            x1_t = int(x1_t) - 1
            y1_t = int(y1_t) - 1
            x2_t = int(x2_t) - 1
            y2_t = int(y2_t) - 1

            print(x1_t, y1_t, x2_t, y2_t)

            #                 curr_depth = round(img_new[x1_t + (x2_t-x1_t)][y1_t + (y2_t-y1_t)],2)
            curr_depth = round(img_new[y1_t + (y2_t - y1_t)][x1_t + (x2_t - x1_t)], 2)

            if curr_depth > high_depth:
                curr_res = result_new
                high_depth = curr_depth

        print("DEPTH", high_depth)

        x1, y1, x2, y2, conf_val, class_id = curr_res

        x1 = int(x1)
        y1 = int(y1)
        x2 = int(x2)
        y2 = int(y2)

        dv = (abs(y2 - y1) * abs(x2 - x1)) / (640 * 480)
        dv = float(format(sigmoid(dv), '.3f'))
        depth_ratio.append(dv)

        cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 1)
        conf_val_new = (int(conf_val_new * 100)) / 100
        depth = high_depth
        cv2.putText(frame, f'Conf:{conf_val_new} Depth(1):{depth} Depth(2): {dv}', (x1 - 90, y1 - 10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.40, (255, 255, 255), 1)

        image = cv.imread("Test.png")
        #             cv2.imshow('frame', frame)
        return frame, depth, conf_val_new, len(results_new), dv
    #             if cv.waitKey(1000) == ord('q'):
    #                 break

    else:

        return frame, None, None, 0, None
def update_image():

    first_occur = True
    first_occur_gyro = True

    #Cancer Video
    # cap = cv2.VideoCapture("cancer_video.mp4")
    
    #Live Camera
    # cap = cv2.VideoCapture(1)

    # Threading for yolov5 detection:
    event = threading.Event()

    yolo_frame = YoloFrame()

    thread = threading.Thread(target=yolorun, kwargs={"weights": "./best.pt", "source": 1,
                                                      "nosave": True, "event": event, "return_img": yolo_frame})

    thread.start()

    # Threading

    x,y,z= 0,0,0
    my_data = [0]
    start_time = datetime.now()
    while True:

        event.set()
        event.clear()


        # Removed cap read for yolov5 detection
        # ret, frame = cap.read()
        # if not ret:
        #     raise Exception("Failed to read image")
        #     break

        frame = yolo_frame.image

        if frame is None:
            time.sleep(5)
            print("Waiting for Yolo...")
            continue

        frame, val, conf, len_tumors, new_dv = run(frame)
        csv_file = "test1.csv"

        new_time = datetime.now()

        time_diff = new_time - start_time

        if time_diff.total_seconds() >= 1.5:
            start_time = new_time

            data = pd.read_csv(csv_file, header=None)
            x, y, z = data.values[0]
            gyro_data_x.append(x)
            gyro_data_y.append(y)
            gyro_data_z.append(z)

        if len(gyro_data_x) > 10:
            gyro_data_x.pop(0)
            gyro_data_y.pop(0)
            gyro_data_z.pop(0)

        if len(gyro_data_x) > 2 and first_occur_gyro:
            gyro_data_x.pop(0)
            gyro_data_y.pop(0)
            gyro_data_z.pop(0)

            first_occur_gyro = False

        if not first_occur_gyro:
            graph_2 = GraphGyro(gyro_data_x, gyro_data_y, gyro_data_z)

        if val != None:

            my_data.append(val)

            if len(my_data) == 3 and first_occur:
                my_data.pop(0)
                depth_ratio.pop(0)

                first_occur = False

            if not first_occur:
                graph = Graph(my_data, depth_ratio)

        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        pil_image = Image.fromarray(frame)

        width, height = 600, 500
        pil_image = pil_image.resize((width, height))

        tk_image = ImageTk.PhotoImage(pil_image)

        image_label.configure(image=tk_image)
        image_label.image = tk_image  

        image_label.place(x=100, y=(70))

        im = Image.open("my_plot.png")
        im = im.resize((462, 320))
        tk_image_2 = ImageTk.PhotoImage(im)

        image_label_2.configure(image=tk_image_2)
        image_label_2.image = tk_image_2

        image_label_2.place(x=800, y=70)

        im = Image.open("gyro_data.png")
        im = im.resize((462, 320))
        tk_image_3 = ImageTk.PhotoImage(im)

        image_label_3.configure(image=tk_image_3)
        image_label_3.image = tk_image_2

        image_label_3.place(x=800, y=420)
        
        text_box = tk.Text(root, width=10, height=1, font=("Arial", 20),pady = 10,highlightbackground="#ff0066", highlightthickness=2, bg="black", fg="white")
        text_box.insert("end",("X:",str(x)))        
        text_box.place(x=280, y=615)
        
        text_box_2 = tk.Text(root, width=10, height=1, font=("Arial", 20),pady = 10,highlightbackground="#5d00ff", highlightthickness=2, bg="black", fg="white")
        text_box_2.insert("end",("Y:",str(y)))        
        text_box_2.place(x=430, y=615)
        
        text_box_3 = tk.Text(root, width=10, height=1, font=("Arial", 20),pady = 10,highlightbackground="#07a822", highlightthickness=2, bg="black", fg="white")
        text_box_3.insert("end",("Z:",str(z)))        
        text_box_3.place(x=580, y=615)
        
        text_box_4 = tk.Text(root, width=16, height=1, font=("Arial", 20),pady = 10,highlightbackground="#5d00ff", highlightthickness=2, bg="black", fg="white")
        text_box_4.insert("end",("Depth(M):",str(my_data[-1])))        
        text_box_4.place(x=280, y=700)
        
        text_box_5 = tk.Text(root, width=16, height=1, font=("Arial", 20),pady = 10,highlightbackground="#ff0066", highlightthickness=2, bg="black", fg="white")
        text_box_5.insert("end",("Depth(E):",str(depth_ratio[-1])))        
        text_box_5.place(x=510, y=700)

        root.update()



    cap.release()


model = torch.hub.load('ultralytics/yolov5', 'custom', "./bestModels/best.pt", force_reload=True)

# from models.experimental import attempt_load
# weights_path = 'path/to/your/model.pt'
# device = 'cuda' if torch.cuda.is_available() else 'cpu'
# model = torch.hub.load('ultralytics/yolov5', 'custom', path='path/to/best.pt')  # local model



def button_click():
    print("Hello")
    update_image()


frame = None

root = tk.Toplevel()
root.geometry("1420x790")
root.configure(bg="black")
root.title('Depth GUI')

frame_curr = Frame(root)
frame_curr.pack()

button_font = ("Arial", 12, "bold")  
button = tk.Button(root, text="START", highlightbackground="#ff0066", command=button_click,width=10, height=5,fg="#ff0066",font=button_font)
button.place(x=100, y=635)

depth_ratio = []

my_data = [0]
depth_ratio = [0]
gyro_data_x = [0]
gyro_data_y = [0]
gyro_data_z = [0]

graph = Graph(my_data, depth_ratio)
plt.savefig('my_plot.png')

graph = GraphGyro(gyro_data_x, gyro_data_y,gyro_data_z)
plt.savefig('gyro_data.png')

padding = 50

image_label = tk.Label(root)

image_label_2 = tk.Label(root)

image_label_3 = tk.Label(root)

text_box_label = tk.Label(root)

# update_image()

# yolorun(weights="./best.pt", source=1)

# time.sleep(2)
root.mainloop()

